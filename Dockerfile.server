# Dockerfile.server
# Multi-stage image that builds both client and server, then serves them together.
# Stage 1: Build the React frontend
# Stage 2: Install server dependencies
# Stage 3: Final runtime image with both frontend and backend

# Stage 1: Build Frontend
FROM node:20-alpine AS client-builder
WORKDIR /usr/src/app/client

# Copy client package files and install dependencies
COPY client/package*.json ./
RUN npm ci

# Copy client source and build
COPY client/ ./
RUN npm run build || ./node_modules/.bin/vite build

# Stage 2: Build Server
FROM node:20-alpine AS server-builder
WORKDIR /usr/src/app/server

# Install production dependencies only
COPY server/package*.json ./
RUN npm ci --only=production

# Copy server source
COPY server/ ./

# Stage 3: Final Runtime Image
FROM node:20-alpine AS runner
WORKDIR /usr/src/app/server

# Create an unprivileged user
RUN addgroup -S app && adduser -S app -G app

# Set production environment variable by default (can be overridden by docker-compose)
ENV NODE_ENV=production

# Copy installed node_modules and server sources from server-builder
COPY --from=server-builder /usr/src/app/server/node_modules ./node_modules
COPY --from=server-builder /usr/src/app/server ./

# Copy the client production build from client-builder stage
# We copy into /usr/src/app/client/dist because server/server.js resolves
# the static path as path.resolve(__dirname, '../client/dist')
COPY --from=client-builder /usr/src/app/client/dist /usr/src/app/client/dist

# Default port (overridable via ENV)
ENV PORT=8080
EXPOSE 8080

# Run as non-root user
USER app

CMD ["node", "server.js"]
